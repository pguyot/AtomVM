# Project: AtomVM

## Project Description
Erlang virtual machine

## Project Structure
- src/libAtomVM - Main source code in C
- libs/ - Main source code in Erlang
- tests/ - test subdirectory
- src/platforms/ - Source code for each platform AtomVM runs on
- .github/workflows/ - CI scripts
- build/ main build directory (using CMake)

## Directories

Set `PROJECT_ROOT` to the project directory.

export PROJECT_ROOT=/Users/paul/Projets/AtomVM/AtomVM

## Build

The build is based on cmake and it is already configured. Build always happen
from the build directory.

Build can be done by running :

```
cd $PROJECT_ROOT/build && cmake --build . | tail -n 10
```

IMPORTANT : unless instructed to do so, do not try to compile erlang source code
from the project with erlc. You will miss the required flags and include paths
and the generated beam will not be placed at the right place.

Build can be verbose. Be sure to tail it.

## Tests

IMPORTANT: never forget to build after making a change before re-running tests

Several kinds of tests can be executed.

Tests of the virtual machine itself are executed with:

```
cd $PROJECT_ROOT/build && ./tests/test-erlang | tail -n 10
```

These tests are small Erlang modules that do not depend on any standard library
and that are in tests/erlang_tests/

Tests of the Erlang libraries can be run with BEAM, the official Erlang VM with, for example jit library:
erl -pa tests/libs/jit/beams/ libs/jit/src/beams/ libs/etest/src/beams -noshell -s tests start -s init stop -noshell

More specifically, `jit_x86_64_asm_tests` which are eunit based can be executed with:

```
cd $PROJECT_ROOT/build && erl -pa tests/libs/jit/beams/ libs/jit/src/beams/ libs/etest/src/beams -noshell -s jit_x86_64_asm_tests test -s init stop -noshell | tail -n 5
```

Eunit tests can generate a lot of output, two lines per test case. Erlang process return code does not indicate if tests succeeded or failed. Look for the summary that is printed at the end to assess if all tests passed.

Alternatively, you can run the following command :

```
cd $PROJECT_ROOT/build && erl -pa tests/libs/jit/beams/ libs/jit/src/beams/ libs/etest/src/beams -noshell -eval 'ok = eunit:test(jit_armv6m_tests)' -s init stop -noshell | tail -n 5
```

In this case, the Erlang process return code will indicate if the expression succeeded, i.e. if eunit:test/1 returned ok.

You can run tests from a generator function like this:

```
cd $PROJECT_ROOT/build && erl -pa tests/libs/jit/beams/ libs/jit/src/beams/ libs/etest/src/beams -noshell -eval 'ok = eunit:test(jit_armv6m_tests:mul_test_())' -s init stop -noshell | tail -n 5
```

You can run a simple single test (not a generator) like this:

```
cd $PROJECT_ROOT/build && erl -pa tests/libs/jit/beams/ libs/jit/src/beams/ libs/etest/src/beams -noshell -eval 'ok = eunit:test(fun jit_armv6m_tests:set_args1_y_reg_test/0)' -s init stop -noshell | tail -n 5
```

## Coverage

It is possible to compute coverage with cover. For example to build a report of coverage of module jit_armv6m:

```
cd $PROJECT_ROOT/build && erl -pa tests/libs/jit/beams/ libs/jit/src/beams/ libs/etest/src/beams -noshell -s cover start -s cover compile_beam jit_armv6m -s jit_armv6m_tests test -s cover analyze_to_file jit_armv6m -s init stop -noshell | tail -n 5
```

## Test-driven development approach

Always adopt a TDD approach

Never assume something works without testing it.
When fixing a bug, analyze then write a test that fails, then fix the bug and check the test passes.

## JIT compiler

Few elements on the jit compiler. It is entirely written in Erlang. The main module is jit (file `libs/jit/src/jit.erl`). This module is entirely backend agnostic.

Each backend is composed of two modules : the assembler module and the main module.
For example, for armv6m backend supporting ARMv6-M (Thumb), the assembler module is `jit_armv6m_asm` and the main module is `jit_armv6m`.

The assembler modules should only export functions that match the regular assembly syntax for the platform. For example, in ARMv6-M it is common to do `bx lr`, this is generated by `jit_armv6m_asm_:bx/1` function when passed a single argument `lr`.

When an assembly syntax consists of elements in braces or brackets, they are passed as a list or as a tuple.

For examples:
- `pop {r1, r2, r4, pc}` is encoded with `jit_armv6m_asm_:pop([r1, r2, r4, pc])`
- `str r2, [r0, #24]` is encoded with `jit_armv6m_asm:str(r2, {r0, 24})`
- `adr r0, .+4` is encoded with `jit_armv6m_asm:adr(r0, 4)`

When working on an assembler (to add a new instruction for example), always write a test to cover it, and ensure the assembler matches using the toolchain (for armv6m, arm-elf-as and arm-elf-objdump are installed).

When working on tests for a main backend module, always compare the generated binary with a disassembled output obtained with objdump.

You can temporarily use armv6m_helper:disassemble/1 function in tests to print the disassembly output, as follows:

```
 shift_left_test() ->
     State0 = ?BACKEND:new(?JIT_VARIANT_PIC, jit_stream_binary, jit_stream_binary:new(0)),
     {State1, Reg} = ?BACKEND:move_to_native_register(State0, {x_reg, 0}),
     State2 = ?BACKEND:shift_left(State1, Reg, 3),
     Stream = ?BACKEND:stream(State2),
+    armv6m_helper:disassemble(Stream),
     Dump =
         <<
             "   0:	6987      	ldr	r7, [r0, #24]\n"
             "   2:	00ff      	lsls	r7, r7, #3"
         >>,
     ?assertEqual(dump_to_bin(Dump), Stream).
```

IMPORTANT : jit compiler emits functions in each module, corresponding to labels, and each of these function have the following signatures:

```
Context *(*ModuleNativeEntryPoint)(Context *ctx, JITState *jit_state, const ModuleNativeInterface *p)
```

There is no function prolog with x86\_64 and aarch64 backends because they have sufficiently scratch registers to work with, but there is a prolog with armv6m backend which pushes registers r1 (`jit_state`) as well as r4-r7 and lr.


## Git workflow

IMPORTANT: When committing changes:
- NEVER use `git add -A`
- ALWAYS explicitly add only the specific files that were modified
- Example: `git add libs/jit/src/jit_wasm.erl libs/jit/include/jit.hrl`

## Other notes

- Files are often too large to fit in context. Always make sure the function you work on is in context to avoid suggesting edits that don't make sense.
- When writing new tests, always look for existing tests to stick with the style.
- Always format code with `erlfmt -w` or `clang-format -i`.
- jit_dwarf is just an empty proxy when DWARF debugging is disabled - don't worry about dwarf state wrapping issues.
